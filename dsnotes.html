<!DOCTYPE html>
<html>
<head>
    <title>Linked List Operations</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
         *, *::before, *::after { box-sizing: border-box; }
         html, body { margin: 0; padding: 0; }
        body {
            font-family: system-ui, Arial, sans-serif;
            line-height: 1.6;
          background: #fafafa;
         color: #202020;
        }
        /* fluid headings: clamp( min , vwâ€‘based , max ) */
    h1 { font-size: clamp(1.7rem, 2.5vw + 1rem, 2.75rem); margin: 0.5em 0; }
    h2 { font-size: clamp(1.3rem, 1.8vw + 0.9rem, 2rem); margin: 1.2em 0 0.4em; }
    h4 { margin: 0.75em 0 0.35em; }
    .wrapper {
         max-width: 70rem;
          margin-inline: auto;
          padding: 1rem;
}
       /* --- Lists & collapsibles --- */
    ol, ul { padding-left: 1.25rem; }
     details { margin-bottom: 1rem; }
summary {
  cursor: pointer;
  font-weight: 600;
  padding: 0.4em 0.6em;
  border-radius: 0.3rem;
  background: #e6f0ff;
  transition: background 0.2s;
}
summary:hover, summary:focus-visible {
  background: #d4e6ff;
  outline: none;
}
pre {
  overflow-x: auto;
  padding: 0.75rem;
  margin: 0.5rem 0 1rem;
  background: #f2f4f8;
  border-left: 4px solid #007bff;
  font-size: 0.9rem;
}
        .section {
            margin: 20px 0;
        }
        .code-block {
            display: none;
            padding: 10px;
            background-color: #f0f0f0;
            border-left: 4px solid #007BFF;
        }
        button {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <h1>Data Structures Notes</h1>
    <ol>
    <li>
   
        <h2>Singly Linked List</h2>
        <p>A single linked list will be like this figure below</p>
        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20250619155958124670/Linked-list.webp"
        alt="linked list img" >
        <p>
            <b>Operations performed on single linked list are : </b>

        </p>
          <!-- traversing -->
         <ul>
             <li> <details>
                <summary><b>Traversing through a list</b></summary>

            <h4>Traversing through a list</h4>
            <p><b>Explanation:</b> visiting all the nodes and printing its data.</p>
            <pre>
Step-1: Initialize a pointer temp to the start of the list.
Step-2:repeat Step-3&4 while(next[temp]==NULL)
Step-3:print data[temp].
Step-4:Move to the next node by updating temp = next[temp].
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240726234303/Traversal-of-Singly-Linked-List.gif"
alt="tarvarsing" height="300">

#include <stdio.h>
#include <stdlib.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node = 
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Function to traverse and print the singly linked list
void traverseList(struct Node* start) {
  Struct node *temp=start;
   
    while (temp!= NULL) {
     
        printf("%d ", temp->data);

    temp = temp->next;
    }
    printf("\n");
}


int main() {
  
    struct Node*start = createNode(10);
    start->next = createNode(20);
    start->next->next = createNode(30);
    start->next->next->next = createNode(40);

    // Example of traversing the node and printing
    traverseList(start);

    return 0;
}
                </pre>
                </details>
                </li>
                </ul>
 </li>
        <!-- Insert at Beginning -->
<ul>
             <li> <details>
                <summary><b>Insert at Beginning</b></summary>

            <h4>Insert at Beginning</h4>
            <p><b>Explanation:</b> A new node is added before the first node.</p>
            <pre>
 Assumption: start is a pointer which points to the first node and the data to be inseerted is 'x'.                
Step 1: Create a node called new node by using malloc.
Step 2: if newnode==null,print "insufficient memory"& exit.
Step 3: Set,data[newnode]=x.
Step-4: Set,next[newnode]=start.
Step-5: Set,start=newnode.
Step-6: EXIT.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240726182404/Insertion-at-the-Beginning-of-Singly-Linked-List.webp"
alt="innserting at the beginning img" height="300">

C Program to insert the node at the beginning of Linked List
#include <stdio.h>
#include <stdlib.h>
// Define a node in the linked list
struct Node {
    int data; // Data stored in the node
    struct Node*
        next; // Pointer to the next node in the list
};
// Function to create a new node with the given data
struct Node* createNode(int data)
{
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Function to insert a new node at the beginning of the list
struct Node* insertAtFront(struct Node* start, int data)
{
    struct Node* new_node = createNode(data);
    new_node->next = start;
    start=new_node;
    return new_node;
}
// Function to print the contents of the linked list
void display(struct Node* start)
{
    // Start from the head of the list
    struct Node *temp=start;
    while (temp != NULL)
     {
        printf(" %d ->", temp->data);

        // Move to the next node
         temp = temp->next;
    }
    printf("\n");
}
int main()
{
    struct Node* start = createNode(2);
    start->next = createNode(3);
    start->next->next = createNode(4);
    start->next->next->next = createNode(5);
    printf("Original Linked List:");
    display(start);

    // Insert a new node at the front of the list
    printf("After inserting Nodes at the front:");
    int data = 1;
    head = insertAtFront(start, data);
    // Print the updated list
    dispaly(start);

    return 0;
}
            </pre>
         </li>
         </details>
           
           </ul>         
        <!-- Insert at End -->
         <ul>
         <li>
        <details>
                <summary><b>Insert at End</b></summary>
            <h4>Insert at End</h4>
            <p><b>Explanation:</b> A new node is added after the last node.</p>
            <pre>
Step 1: Create a node called new node.
Step 2:if newnode==NULL,print " Insufficient memory" & exit
Step 3: Set,data[newnode]=data.
Step-4: Set,next[newnode]=NULL.
Step-5: create a pointer temp assign it to start.
Step-6: Repeat step-7 while(next[temp]!=NULL)
Step-7: temp=next[temp].
Step-8: next[temp]=newnode.
Step-9: EXIT.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240729103612/Insertion-at-the-End-of-Singly-Linked-List.webp"
alt="insert at the end img" height="200">
// c program to insert at the last 
#include <stdio.h>
#include <stdlib.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node = 
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Given the head of a list and an int, appends
// a new node at the end and returns the head.
struct Node* append(struct Node* start, int new_data) {
  
    // Create a new node
    struct Node* new_node = createNode(new_data);

    // If the Linked List is empty, make
    // the new node as the head and return
    if (head == NULL) {
        return new_node;
    }

    // Store the head reference in a temporary variable
    struct Node* last =start;

    // Traverse till the last node
    while (last->next != NULL) {
        last = last->next;
    }

    // Change the next pointer of the last node 
    // to point to the new node
    last->next = new_node;

    return start;
}

// This function prints the contents 
// of the linked list starting from the head
void printList(struct Node* node) {
    while (node != NULL) {
        printf(" %d", node->data);
        node = node->next;
    }
}

int main() {
  
    // Create a hard-coded linked list: 
    // 2 -> 3 -> 4 -> 5 -> 6
    struct Node* strat = createNode(2);
    head->next = createNode(3);
    start->next->next = createNode(4);
    start->next->next->next = createNode(5);
    start->next->next->next->next = createNode(6);

    printf("Created Linked list is:");
    printList(start);

    // Example of appending a node at the end
    head = append(head, 1);

    printf("\nAfter inserting 1 at the end:");
    printList(start);

    return 0;
}

            </pre>
         </div>
        </details>
        </li>
        
        </ul>
         <!--inserting at a specific location-->
         <ul>
         <li>
            <details>
                <summary><b>Insertion at a specific location</b></summary>
                  <h4>Insert at a specific location</h4>
            <p><b>Explanation:</b> A new node is added at a specific location.</p>
            <pre>
Step 1: Create a node called new node.
Step 2:if newnode==NULL,print " Insufficient memory" & exit
Step-3: read data 'x.'
Step 4: Set,data[newnode]=data.
Step-5: Set,next[newnode]=NULL.
Step-6: Read the location.
Step-7: create a pointer temp assign it to start.
Step-8: Set i=1.
Step-9: Repeat step-10&11 while(next[temp]!=NULL && i less than (location-1))
Step-10: temp=next[temp].
Step-11:i++.
Step-12:if(next[temp]==NULL) then print "no specific location"& EXIT.
Step-13:Set,next[newnode]=next[temp].
Step-14ext[temp]=newnode.
Step-15: EXIT.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240902143425/Insertion-at-a-Specific-Position-of-the-Singly-Linked-List-copy.webp" alt="insertion at the position img" height="300">
// C program for insertion in a single linked ist at a specified position

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node *next;
};

struct Node *createNode(int x);

// Function to insert a Node at the required position
struct Node *insertPos(struct Node *start, pos, int data) {

    // return if invalid input
    if (pos < 1)
        return start;

    // Head will change if pos=1
    if (pos == 1) {
        struct Node *newNode = createNode(data);
        newNode->next = head;
        return newNode;
    }

    struct Node *temp = start;

    // Traverse to the node that will be present before the new node
    for (int i = 1; i < pos - 1 && curr != NULL; i++) {
        temp= temp->next;
    }
    
    // if position is greater than
    // number of nodes
    if (temp == NULL) 
        return start;
        
    struct Node *newNode = createNode(data);

    // Update the next pointers
    newNode->next = temp->next;
    temp->next = newNode;

    return start;
}

void printList(struct Node *start) {
    struct Node *temp = start;
    while (temp != NULL) {
        printf("%d ->", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

struct Node *createNode(int x) {
    struct Node *new_node = 
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = x;
    new_node->next = NULL;
    return new_node;
}

int main() {

    // Creating the list 3->5->8->10
    struct Node *start = createNode(3);
    start->next = createNode(5);
    start->next->next = createNode(8);
    start->next->next->next = createNode(10);

    int data = 12, pos = 3;
    start = insertPos(start, pos, data);
    printList(start);

    return 0;
}

            </pre>
            
            </details>
         </li>
        </ul>
        <!-- Delete from Beginning -->
         <ul>
         <li>
        <details>
            <summary><b>Delete from beginning</b></summary>
            <h4>Delete from Beginning</h4>
            <p><b>Explanation:</b> Remove the head node and update the head to the next node.</p>
            
            <pre>
          
Step 1: Check if list is empty if start==NULL,print "underflow" & EXIT.
Step 2: create a pointer named temp and assign it to start.
Step 3: Set,start=next[start].
Step-4: deallocate the memory occupied by the first node by calling free(temp) & Exit.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240827131844/Deletion-at-beginning-.webp" alt="deleting first node img" height="300">
// C program to delete the first node from a linked list

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};

struct Node* deletestart(struct Node* start) {
  
    // Check if the list is empty
    if (start== NULL)
        return NULL;

  
    struct Node* temp = start;

    start= start->next;

    // Free the memory of the old head node
    free(temp);

    return start;
}

void printList(struct Node* curr) {
  	
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
}
struct Node *createNode(int new_data){
    struct Node *new_node =
      (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

int main() {
  
    // Create a hard-coded linked list:
    // 3 -> 12 -> 15 -> 18
    struct Node* start = createNode(3);
    start->next = createNode(12);
    start->next->next = createNode(15);
    start->next->next->next = createNode(18);
    start = deleteHead(start);
    printList(start);

    return 0;
}
            </pre>
            </ul>
        </details>
        </ul>
        <!-- deleting the last node -->
         <ul>
         <li>
        <details>
            <summary><b>Deleting the last node</b></summary>
            <h4>Deleting the last node</h4>
            <p><b>Explanation:</b> Removing the last node of the list .</p>
            
            <pre>
          
Step 1: Check if list is empty if start==NULL,print "underflow" & EXIT.
Step 2: create a pointer named temp and assign it to start.
Step-3: Create a pointer named prev and assign it to NULL.
Step-4: Repeat Step-5&6 while(next[temp]!=NULL)
Step-5: prev=temp.
Step-6: temp=next[temp].
Step-7: Set, next[prev]=NULL.
Step-8: deallocate the memory occupied by the last node by calling free(temp) & Exit.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240730120651/Deletion-At-End.webp" alt="deleting last node img" height="300">
</pre>
            </ul>
        </details>
        </ul>
        <!-- deleting a specific node -->
         <ul>
         <li>
        <details>
            <summary><b>Deleting a specific node</b></summary>
            <h4>Deleting a specific node</h4>
            <p><b>Explanation:</b> Removing the specific node .</p>
            
            <pre>
          
Step 1: Check if list is empty if start==NULL,print "underflow" & EXIT.
Step 2: create a pointer named temp and assign it to start.
Step-3: Create a pointer named prev and assign it to NULL.
Step-4: Read the location.
Step-5: Set,i=1.
Step-6: Repeat Step-7-9 while(next[temp]!=NULL && i less than location)
Step-7: prev=temp.
Step-8: temp=next[temp].
Step-9:i++.
Step-10: if(next[temp]==NULL && i!=location) then print "location not found" & EXIT.
Step-11: Set,next[prev]=next[temp].
Step-12: deallocate the memory occupied by the last node by calling free(temp) & Exit.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240729185435/Deletion-specific-At-End--.webp" alt="deleting specific node img" height="200">
// C program to delete a linked list node at a given position

#include <stdio.h>
#include <stdlib.h>

// Node structure for the linked list
struct Node {
    int data;
    struct Node* next;
};

struct Node* newNode(int data)
{
    struct Node* node = (struct Node*)malloc(sizeof(struct Node));
    node->data = data;
    node->next = NULL;
    return node;
}

// Function to delete a node at a given position
struct Node* deleteNode(struct Node* start, int position)
{
    struct Node* temp = start;
    struct Node* prev = NULL;

    // Base case if linked list is empty
    if (temp == NULL)
        return start;

    // Case 1: start is to be deleted
    if (position == 1) {
        start= temp->next;
        free(temp);
        return start;
    }

    // Case 2: Node to be deleted is in middle Traverse till given position
    for (int i = 1; temp != NULL && i < position; i++) {
        prev = temp;
        temp = temp->next;
    }

    // If given position is found, delete node
    if (temp != NULL) {
        prev->next = temp->next;
        free(temp);
    }
    else {
        printf("Data not present\n");
    }

    return start;
}

void printList(struct Node* start)
{
    while (start!= NULL) {
        printf("%d -> ", start->data);
        start = start->next;
    }
    printf("NULL\n");
}

int main()
{
    struct Node* start = newNode(1);
    start->next = newNode(2);
   start->next->next = newNode(3);
    start->next->next->next = newNode(4);
    start->next->next->next->next = newNode(5);

    printf("Original list: ");
    printList(start);

    int position = 2;
    head = deleteNode(start, position);

    printf("List after deletion: ");
    printList(start);

    // Cleanup remaining nodes
    while (start != NULL) {
        struct Node* temp = start;
        start = start->next;
        free(temp);
    }

    return 0;
}
</pre>
            </ul>
        </details>
        </ul>
         </div>
         </li>
         <!-- searching -->
         <ul>
         <li>
        <details>
            <summary><b>searching a specific node</b></summary>
            <h4>searching a specific node</h4>
            <p><b>Explanation:</b> Searching the existence of a specific node .</p>
            
            <pre>
Step-1: if start==NULL print "no list found"& exit.
Step-2: Create a pointer named temp and assign it to start.
Step-3: enter the key value.
Step-4:  while (temp != NULL) repeat step 5&6.
Step-5:  if (data[temp] == key) then print data[temp]
 Step-6: temp = next[temp];
 Step-7: else return false.& exit 

// Iterative C program to search an element in linked list

#include <stdio.h>
#include <stdbool.h>

// A linked list node
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int new_data) {
    struct Node* new_node = 
       (struct Node*)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Checks whether key is present in linked list
bool searchKey(struct Node* start, int key) {

    // Initialize curr with the head of linked list
    struct Node* temp=start;

    // Iterate over all the nodes
    while (temp != NULL) {

        // If the current node's value is equal to key,
        // return true
        if (temp->data == key)
            return true;

        // Move to the next node
        temp = temp->next;
    }

    // If there is no node with value as key, return false
    return false;
}


int main() {
  
    // Create a hard-coded linked list:
    // 14 -> 21 -> 13 -> 30 -> 10
    struct Node* head = createNode(14);
    start->next = createNode(21);
    start->next->next = createNode(13);
    start->next->next->next = createNode(30);
    start->next->next->next->next = createNode(10);

  	// Key to search in the linked list
  	int key = 14;
  
    if (searchKey(start, key))
		printf("Yes");
    else
        printf("No");

    return 0;
}
            </pre>
       </li>
       </ul>
    <div class="section">
        <li>
        <h2>Doubly Linked List</h2>
        <p>A double linked list will be like this figure below</p>
        <img src="https://media.geeksforgeeks.org/wp-content/uploads/20240809123741/Insertion-at-the-End-in-Doubly-Linked-List-copy.webp"
        alt="Double linked list img" >
        <p>
            <b>Operations performed on double linked list are :</b>
        </p>
         <ul>
         <li>
        <!-- Traversing through a double linked list -->
             <details>
            <summary><b>Traversing through DLL</b></summary>
                <h4>Traversing through DLL</h4>
                <p><b>Explanation:</b> Visiting all the nodes and printing the data</p>
            <pre>
// C Program for Forward Traversal (Iterative) of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to traverse the doubly linked list in forward direction
void forwardTraversal(struct Node* start) {
    struct Node* temp = start;

    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

int main() {
  
    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 3
    struct Node* start = createNode(1);
    struct Node* second = createNode(2);
    struct Node* third = createNode(3);

    start->next = second;
    second->prev = start;
    second->next = third;
    third->prev = second;

    printf("Forward Traversal: ");
    forwardTraversal(start);

    return 0;
}
            </pre>        
        

            </li>
            </ul>
            <ul>
                <li>
        <!-- Insert at Beginning -->
             <details>
            <summary><b>Inserting a node at the beginning</b></summary>
            <h4>Insert at Beginning</h4>
            <p><b>Explanation:</b> A new node is added before the start and both next and prev pointers are updated.</p>
            <pre>
Step 1: Create a new node.
Step 2: If newnode==NULL, print "insufficient memory" & exit.
Step 3: Set,prev[newnode]=NULL.
Step 4: Set,data[newnode]=x.
Step-5: Set,next[newnode]=start.
Step-6: Set, prev[start]=newnode.
Step-7: Set,start=newnode & exit.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240806180443/Insertion-at-the-Beginning-in-Doubly-Linked-List.webp"
alt="Dll-inserting at front img",height="300">
// C Program to insert a node at the beginning of doubly
// linked list

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev
};

// Function to create a new node
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

// C program to insert a new node at the front of doubly linked list
struct Node *insertAtFront(struct Node *start, int new_data) {

    struct Node *new_node = createNode(new_data);

    new_node->next = start;

    if (start != NULL) {
        start->prev = new_node;
    }

    // Return the new node as the head of the doubly linked list
    return new_node;
}

void printList(struct Node *start) {
    struct Node *temp = start;
    while (temp != NULL) {
        printf(" %d", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {

    // Create a hardcoded doubly linked list:
    // 2 <-> 3 <-> 4 -> NULL
    struct Node *start = createNode(2);
    start->next = createNode(3);
    start->next->prev = start;
    start->next->next = createNode(4);
   start->next->next->prev = start->next;

    printf("Original Linked List:");
    printList(start);

    // Insert a new node at the front of the list
    printf("After inserting Node at the front:");
    int data = 1;
    start = insertAtFront(start, data);

    // Print the updated list
    printList(start);

    return 0;
}
            </pre>
        </details>

        

     </div>
     </ul>
     </li>
     <ul>
         <li>
        <!-- Insert at the end-->
             <details>
            <summary><b>Inserting a node at the end</b></summary>
            <h4>Insert at the end</h4>
            <p><b>Explanation:</b> Insert a new node at the end of the linked list.</p>
            <pre>
Assuming that start is a pointer which points to the first node and last is a pointer which points the last
node.The last pointer is assigned by traversing through the list.
Step-1:Create node called newnode.
Step-2: If newnode==NULL,print " insufficient money" & exit.
Step-3: Set,data[newnode]=x.
Step-4: Set,next[newnode]=NULL.
Step-5: Set,prev[newnode]=last.
Step-6: Set,next[last]=newnode.
Step-7: last=newnode & exit.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240807153259/Insertion-at-the-End-in-Doubly-Linked-List.webp"
alt="DLL inserting at end img"height="300">
// C Program to insert a node at the end of doubly linked list

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to create a new node with the given data
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// C program to insert a new node at the end of the doubly linked list
struct Node* insertEnd(struct Node *head, int new_data) {
    struct Node *new_node = createNode(new_data);

    if (start == NULL) {
        start = new_node;
    } else {
        struct Node *temp = start;
        while (temp->next != NULL) {
            temp = temp->next;
        }

        // Set the next of last node to new node
        temp->next = new_node;
        // Set prev of new node to last node
        new_node->prev = temp;
    }

    return start;
}

void printList(struct Node *start) {
    struct Node *temp = start;
    while (temp != NULL) {
        printf("%d ", temp->data);
        temp = temp->next;
    }
    printf("\n");
}

int main() {
  
    struct Node *start = createNode(1);
    start->next = createNode(2);
    start->next->prev = start;
    start->next->next = createNode(3);
    start->next->next->prev = start->next;

    // Print the original list
    printf("Original Linked List: ");
    printList(start);

    // Insert a new node with data 4 at the end
    printf("Inserting Node with data 4 at the end: ");
    start = insertEnd(start, 4);

    printList(start);

    return 0;
}
            </pre>
     </li>
    </ul>
</details>
    <ul>
         <li>
        <!-- Insert at the end-->
             <details>
            <summary><b>Inserting a node at a specific position</b></summary>
            <h4>Insert at a specific position</h4>
            <p><b>Explanation:</b> Insert a new node at the given position in the linked list.</p>
            <pre>
Step-1: Create a node called newnode.
Step-2: If position = 1,  make it the start of the linked list and return it.
Step-3: Otherwise, traverse the list to reach the node at position â€“ 1, say curr.
Step-4: If the position is valid, create a new node with given data, say new_node.
Step-5: Update the next pointer of new node to the next of current node and prev pointer of new node to current node, new_node->next = curr->next and new_node->prev = curr.
Step-6: Similarly, update next pointer of current node to the new node, curr->next = new_node.
Step-7: If the new node is not the last node, update prev pointer of new nodeâ€™s next to the new node, new_node->next->prev = new_node.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240807121739/Insertion-at-a-Specific-Position-in-Doubly-Linked-List.webp"
alt="DLL inserting at a specific position img" height="300">

// C Program to insert a node at a given position

#include <stdio.h>

struct Node {
    int data;
    struct Node *next;
    struct Node *prev;
};

// Function to create a new node with the given data
struct Node *createNode(int new_data) {
    struct Node *new_node = (struct Node *)malloc(sizeof(struct Node));
    new_node->data = new_data;
    new_node->next = NULL;
    return new_node;
}

// Function to insert a new node at a given position
struct Node* insertAtPosition(struct Node *start, int pos, int new_data) {
    // Create a new node
    struct Node *new_node = createNode(new_data);

    // Insertion at the beginning
    if (pos == 1) {
        new_node->next = start;

        // If the linked list is not empty, set the prev of start to new node
        if (start!= NULL) {
           start->prev = new_node;
        }

       start = new_node;
        return start;
    }

    struct Node *curr = start;
  
    // Traverse the list to find the node before the insertion point
    for (int i = 1; i < pos - 1 && curr != NULL; ++i) {
        curr = curr->next;
    }

    // If the position is out of bounds
    if (curr == NULL) {
        printf("Position is out of bounds.\n");
        free(new_node);
        return Start;
    }

    // Set the prev of new node to curr
    new_node->prev = curr;

    // Set the next of new node to next of curr
    new_node->next = curr->next;

    // Update the next of current node to new node
    curr->next = new_node;

    // If the new node is not the last node, update the prev of next node to new node
    if (new_node->next != NULL) {
        new_node->next->prev = new_node;
    }

    return start;
}

// Function to print the linked list
void printList(struct Node *start) {
    struct Node *curr = start;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\n");
}

int main() {
  
    // Create a hardcoded doubly linked list:
    // 1 <-> 2 <-> 4
    struct Node *start = createNode(1);
    start->next = createNode(2);
    start->next->prev = start;
    start->next->next = createNode(4);
    start->next->next->prev = start->next;

    // Print the original list
    printf("Original Linked List: ");
    printList(start);

    // Insert new node with data 3 at position 3
    printf("Inserting Node with data 3 at position 3: ");
    int data = 3;
    int pos = 3;
    start = insertAtPosition(start, pos, data);

    // Print the updated list
    printList(start);

    return 0;
}
            </pre>
             </li>     
        </ul>

            </details>
            <ul>
         <li>
        <!-- Deleting a node at the beginning-->
             <details>
            <summary><b>Deleting a node at the beginning</b></summary>
            <h4>Deleting a node at the beginning</h4>
            <p><b>Explanation:</b> Deleting a node at the first position of the linked list.</p>
            <pre>
Step-1: If start==NULL,print "underflow" & exit.
Step-2: Set,temp=start.
Step-3: Set,start=next[temp].
Step-4: Set,prev[start]= NULL.
Step-5: free(temp).
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240809124112/Deletion-at-the-Beginning-of-Doubly-Linked-List.webp"
alt="DLL deleting a node at the beginning" height="250">
// C Program to delete a node from the beginning of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node *prev;
    struct Node *next;
};

// Function to delete the first node (head) of the list and return the second node as the new head
struct Node *delHead(struct Node *start) {
  
    // If empty, return NULL
    if (head == NULL)
        return NULL;

    // Store in temp for deletion later
    struct Node *temp = start;

    start = start->next;

    if (start != NULL)
        start->prev = NULL;

    // Free memory and return new head
    free(temp);
    return start;
}

// Function to create a new node
struct Node *createNode(int data) {
    struct Node *newNode = (struct Node *)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

void printList(struct Node *start) {
    struct Node *curr = start;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\n");
}

int main() {

    struct Node *start = createNode(1);
    start->next = createNode(2);
    start->next->prev = start;
    start->next->next = createNode(3);
    start->next->next->prev = start->next;

    printf("Original Linked List: ");
    printList(start);

    printf("After Deletion at the beginning: ");
    head = delHead(start);

    printList(start);
    return 0;
}
</pre>
</li>
</ul>
            </details>
             <ul>
         <li>
        <!-- Deleting a node at the end-->
             <details>
            <summary><b>Deleting a node at the end</b></summary>
            <h4>Deleting a node at the end</h4>
            <p><b>Explanation:</b> Deleting a node at the end in the linked list.</p>
            <pre>
Step-1: If start==NULL, print "underflow"& exit.
Step-2: Set, etmp=Start.
Step-3: Set, last=prev[temp].
Step-4: Set, next[last]=NULL.
Step-5: free(temp).
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240809124140/Deletion-at-the-End-in-Doubly-Linked-List.webp"
alt="DLL deletion at the end img" height="250">

// C Program to delete a node from the end of Doubly Linked List

#include <stdio.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to delete the last node of the doubly linked list
struct Node* delLast(struct Node *start) {
  
    // Corner cases
    if (start == NULL)
        return NULL;
    if (start->next == NULL) {
        free(start);
        return NULL;
    }

    // Traverse to the last node
    struct Node *curr = start;
    while (curr->next != NULL)
        curr = curr->next;

    // Update the previous node's next pointer
    curr->prev->next = NULL;

    free(curr);

    return start;
}
t
void printList(struct Node *start) {
    struct Node *curr = start;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\n");
}

// Function to create a new node
struct Node* createNode(int data) {
    struct Node *newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->prev = NULL;
    newNode->next = NULL;
    return newNode;
}

int main() {
  
    struct Node *start = createNode(1);
    start->next = createNode(2);
    start->next->prev =start;
    start->next->next = createNode(3);
    start->next->next->prev = start->next;

    printf("Original Linked List: ");
    printList(start);

    printf("After Deletion at the end: ");
    start = delLast(start);

    printList(start);

    return 0;
}   
            </pre>
             </li>
             </ul>
            </details>
              <ul>
         <li>
        <!-- Deleting a node at a specific position-->
             <details>
            <summary><b>Deleting a node at a specific position</b></summary>
            <h4>Deleting a node at a specific position</h4>
            <p><b>Explanation:</b> Deleting a node at the given position in the linked list.</p>
            <pre>
To delete a node at a specific position in doubly linked list, we can use the following steps:

1. Traverse to the node at the specified position, say curr.
2. If the position is valid, adjust the pointers to skip the node to be deleted.
3. If curr is not the head of the linked list, update the next pointer of the node before curr to point to the node after curr, curr->prev->next = curr-next.
4. If curr is not the last node of the linked list, update the previous pointer of the node after curr to the node before curr, curr->next->prev = curr->prev.
5. Free the memory allocated for the deleted node.
<img src="https://media.geeksforgeeks.org/wp-content/uploads/20240812114214/Deletion-at-a-Specific-Position-in-Doubly-Linked-List.webp"
alt="DLL deleting at a position img" height="250">
// C Program to delete node at a specific position in Doubly Linked List

#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* prev;
    struct Node* next;
};

// Function to delete a node at a specific position in the doubly linked list
struct Node* delPos(struct Node* start, int pos) {

    // If the list is empty
    if (start == NULL)
        return start;

    struct Node* curr = start;

    for (int i = 1; curr != NULL && i < pos; ++i) {
        curr = curr->next;
    }

    // If the position is out of range
    if (curr == NULL)
        return start;

    // Update the previous node's next pointer
    if (curr->prev != NULL)
        curr->prev->next = curr->next;

    // Update the next node's prev pointer
    if (curr->next != NULL)
        curr->next->prev = curr->prev;

    if (start == curr)
        start = curr->next;

    // Deallocate memory for the deleted node
    free(curr);
    return start;
}

void printList(struct Node* start) {
    struct Node* curr = start;
    while (curr != NULL) {
        printf("%d ", curr->data);
        curr = curr->next;
    }
    printf("\n");
}

struct Node* createNode(int d) {
    struct Node* new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->data = d;
    new_node->prev = NULL;
    new_node->next = NULL;
    return new_node;
}

int main() {

    struct Node* start = createNode(1);
    start->next = createNode(2);
    start->next->prev = start;
    start->next->next = createNode(3);
    start->next->next->prev = start->next;

    start = delPos(start, 2);

    printList(start);

    return 0;
}
            </pre>
             </li>
             </ul>
            </details>
   </ol> 
</body>
</html>